#!/usr/bin/env python3
import argparse
import datetime
import os
import re
import shutil
import zipfile
from pathlib import Path

# --- Config ---
IMAGE_EXTS = {".png", ".jpg", ".jpeg", ".webp"}

# --- Helpers ---

def slugify(text: str) -> str:
    """Convert a string into a URL/filename-safe slug."""
    text = text.lower()
    text = re.sub(r"[^\w\s-]", "-", text)
    text = re.sub(r"[\s_-]+", "-", text)
    return text.strip("-")

def bytes_to_mb(num_bytes: int) -> str:
    return f"{num_bytes / (1024 * 1024):.1f} MB"

def prompt_optional(label: str):
    val = input(f"{label} (optional): ").strip()
    return val if val else None

def extract_worldname_from_zipname(zip_path: Path) -> str | None:
    name = zip_path.stem
    # remove leading dates (e.g. 20 06 12 or 26 01 04)
    name = re.sub(r"^\d{2}\s+\d{2}\s+\d{2}\s+", "", name)
    # remove bracketed junk (ND), (*), etc
    name = re.sub(r"\([^)]*\)", "", name)
    name = re.sub(r"\[[^]]*\]", "", name)
    # remove long numeric IDs (timestamps)
    name = re.sub(r"\b\d{10,}\b", "", name)
    # collapse whitespace
    name = re.sub(r"\s+", " ", name).strip()
    return name if name else None

def is_real_file(path: Path) -> bool:
    """Ignore macOS metadata files in ZIPs."""
    return not path.name.startswith("._") and "__MACOSX" not in path.parts

# --- Main ---
def main():
    parser = argparse.ArgumentParser(description="Add Eden world to site")
    parser.add_argument("--eden", required=True, help="Path to .zip file containing .eden")
    parser.add_argument("--preview", help="Preview image (optional)")
    parser.add_argument("--map", help="Map image (optional)")
    args = parser.parse_args()

    eden_zip = Path(args.eden).resolve()
    if not eden_zip.exists():
        raise FileNotFoundError(f"Eden zip not found: {eden_zip}")

    # Suggest worldname from ZIP filename
    suggested_name = extract_worldname_from_zipname(eden_zip)
    if suggested_name:
        prompt = f"World name [{suggested_name}]: "
        worldname = input(prompt).strip()
        if not worldname:
            worldname = suggested_name
    else:
        worldname = input("World name: ").strip()
    if not worldname:
        raise ValueError("World name is required")

    archivedate = prompt_optional("Archive date (YYYY-MM-DD)")
    author = prompt_optional("Author")
    tags_raw = prompt_optional("Tags (comma separated)")
    tags = [t.strip() for t in tags_raw.split(",")] if tags_raw else []

    # --- Extract ZIP ---
    extract_dir = Path("/tmp") / f"eden_extract_{os.getpid()}"
    extract_dir.mkdir(parents=True, exist_ok=True)

    eden_file = None
    image_candidates = []

    with zipfile.ZipFile(eden_zip, "r") as z:
        for info in z.infolist():
            name = Path(info.filename)
            suffix = name.suffix.lower()
            if suffix == ".eden" and is_real_file(name):
                extracted_path = Path(z.extract(info, extract_dir)).resolve()
                if eden_file is not None:
                    raise ValueError("Zip contains more than one real .eden file")
                eden_file = extracted_path
            elif suffix in IMAGE_EXTS and is_real_file(name):
                extracted_path = Path(z.extract(info, extract_dir)).resolve()
                image_candidates.append(extracted_path)

    if eden_file is None:
        raise ValueError("Zip does not contain a .eden file")

    # --- Numeric ID and publish date ---
    eden_match = re.match(r"(\d+)\.eden$", eden_file.name)
    if not eden_match:
        raise ValueError("The .eden file does not have a numeric filename")
    world_id = eden_match.group(1)
    publish_date = datetime.date.fromtimestamp(int(world_id)).isoformat()

    # --- Compute filesize from .eden ---
    filesize = bytes_to_mb(eden_file.stat().st_size)

    # --- Create asset directory ---
    asset_dir = Path("assets/worldfiles") / world_id
    asset_dir.mkdir(parents=True, exist_ok=True)

    shutil.copy2(eden_zip, asset_dir / eden_zip.name)

    # Copy preview if provided
    if args.preview:
        shutil.copy2(args.preview, asset_dir / f"{world_id}.eden.png")

    # Determine map image
    chosen_map = None
    if args.map:
        chosen_map = Path(args.map)
    elif image_candidates:
        chosen_map = max(image_candidates, key=lambda p: p.stat().st_size)

    if chosen_map:
        shutil.copy2(chosen_map, asset_dir / "map.png")

    # Marker file
    (asset_dir / worldname).touch()

    # --- Create markdown ---
    slug = slugify(worldname)
    md_path = Path("_worlds") / f"{slug}.md"

    fm = [
        "---",
        "layout: page",
        f"filename: {world_id}.eden",
        f"worldname: {worldname}",
        f"publishdate: {publish_date}",
        f"archivedate: {archivedate or ''}",
        f'filesize: "{filesize}"',
        f"author: {author or ''}",
        "tags:",
    ]
    for tag in tags:
        fm.append(f"  - {tag}")

    fm.extend([
        "---",
        f"## {worldname}",
        "",
        "There may be an article available for this world. Check back soon!",
        "",
        f"![Preview Image]({{{{ site.baseurl }}}}/assets/worldfiles/{world_id}/{world_id}.eden.png)",
        "",
        "{% include world-details.html %}",
        "",
        "{% include world-download.html %}",
        "",
        "Note: World downloads are compressed, and must be unzipped before played.",
        "",
        "## Map",
        "",
        f"![Map]({{{{ site.baseurl }}}}/assets/worldfiles/{world_id}/map.png)",
        ""
    ])

    md_path.write_text("\n".join(fm), encoding="utf-8")

    # Cleanup
    shutil.rmtree(extract_dir)

    print(f"âœ… World added: {md_path}")

# --- Run ---
if __name__ == "__main__":
    main()
